# -*- coding: utf-8 -*-
"""Data Processing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zz6OuLsA4-Wccp-rtqJklxP5KPB5Alua

# **CSE 572 Semantic Web Mining**


### Personality Prediction

**This notebook contains the code for initial data processing.
"""

# Importing all the required header files

import pandas as pd
import scipy as sp
from scipy import sparse
from sklearn import preprocessing 
from google.colab import drive

# Mounting the drive
drive.mount('/content/drive')

#Loading the datasets
base_path = "/content/drive/Shareddrives/CSE 573 Project/dataset/"
raw_users = pd.read_csv(base_path+"users.csv")
raw_likes = pd.read_csv(base_path+"likes.csv")
raw_association = pd.read_csv(base_path+"users-likes.csv")

# printing the raw user data
raw_users.head(5)

# printing the raw likes data
raw_likes.head(5)

# printing the raw association data
raw_association.head(5)

# Performing Join on associaiton and likes
association_likes = raw_association.join(raw_likes.set_index('likeid'), on="likeid")

# renaming the column name from name to text
association_likes.rename(columns={'name': 'text'}, inplace=True)

association_likes.head(5)

# Performing Join on association and users
association_all = association_likes.join(raw_users.set_index('userid'), how="outer", on="userid")

# Getting an idea about the data using info method
association_all.info(verbose=True, show_counts=True)

"""From the above statistics, we can see that the political column has very high NaN values. Calculating the percentage of NaN values to see if we can eliminate the column as a whole."""

# Calculating the percentage of NaN values in each column
association_all.isnull().sum() * 100 / len(association_all)

"""**We can see that more than 75% values in political is NaN.**"""

# Dropping political col because of many 'NaN' datapoints
association_all.drop(['political'], axis=1, inplace=True)
association_all.head()

#Datatype handling for different datatypes(String, int) in order to convert to sparse matrix
print(association_all.dtypes)
association_all.apply(preprocessing.LabelEncoder().fit_transform)

#Converting dataframe to sparse matrix
#Datatype handling for different datatypes in df

sparse_matrix = sp.sparse.csr_matrix(association_all.values)